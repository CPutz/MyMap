// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace OSMPBF {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class Fileformat {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    #endregion
    #region Extensions
    internal static readonly object Descriptor;
    static Fileformat() {
      Descriptor = null;
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Blob : pb::GeneratedMessageLite<Blob, Blob.Builder> {
    private Blob() { }
    private static readonly Blob defaultInstance = new Blob().MakeReadOnly();
    private static readonly string[] _blobFieldNames = new string[] { "OBSOLETE_bzip2_data", "lzma_data", "raw", "raw_size", "zlib_data" };
    private static readonly uint[] _blobFieldTags = new uint[] { 42, 34, 10, 16, 26 };
    public static Blob DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Blob DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Blob ThisMessage {
      get { return this; }
    }
    
    public const int RawFieldNumber = 1;
    private bool hasRaw;
    private pb::ByteString raw_ = pb::ByteString.Empty;
    public bool HasRaw {
      get { return hasRaw; }
    }
    public pb::ByteString Raw {
      get { return raw_; }
    }
    
    public const int RawSizeFieldNumber = 2;
    private bool hasRawSize;
    private int rawSize_;
    public bool HasRawSize {
      get { return hasRawSize; }
    }
    public int RawSize {
      get { return rawSize_; }
    }
    
    public const int ZlibDataFieldNumber = 3;
    private bool hasZlibData;
    private pb::ByteString zlibData_ = pb::ByteString.Empty;
    public bool HasZlibData {
      get { return hasZlibData; }
    }
    public pb::ByteString ZlibData {
      get { return zlibData_; }
    }
    
    public const int LzmaDataFieldNumber = 4;
    private bool hasLzmaData;
    private pb::ByteString lzmaData_ = pb::ByteString.Empty;
    public bool HasLzmaData {
      get { return hasLzmaData; }
    }
    public pb::ByteString LzmaData {
      get { return lzmaData_; }
    }
    
    public const int OBSOLETEBzip2DataFieldNumber = 5;
    private bool hasOBSOLETEBzip2Data;
    private pb::ByteString oBSOLETEBzip2Data_ = pb::ByteString.Empty;
    [global::System.ObsoleteAttribute()]
    public bool HasOBSOLETEBzip2Data {
      get { return hasOBSOLETEBzip2Data; }
    }
    [global::System.ObsoleteAttribute()]
    public pb::ByteString OBSOLETEBzip2Data {
      get { return oBSOLETEBzip2Data_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _blobFieldNames;
      if (hasRaw) {
        output.WriteBytes(1, field_names[2], Raw);
      }
      if (hasRawSize) {
        output.WriteInt32(2, field_names[3], RawSize);
      }
      if (hasZlibData) {
        output.WriteBytes(3, field_names[4], ZlibData);
      }
      if (hasLzmaData) {
        output.WriteBytes(4, field_names[1], LzmaData);
      }
      if (hasOBSOLETEBzip2Data) {
        output.WriteBytes(5, field_names[0], OBSOLETEBzip2Data);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRaw) {
          size += pb::CodedOutputStream.ComputeBytesSize(1, Raw);
        }
        if (hasRawSize) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, RawSize);
        }
        if (hasZlibData) {
          size += pb::CodedOutputStream.ComputeBytesSize(3, ZlibData);
        }
        if (hasLzmaData) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, LzmaData);
        }
        if (hasOBSOLETEBzip2Data) {
          size += pb::CodedOutputStream.ComputeBytesSize(5, OBSOLETEBzip2Data);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasRaw) hash ^= raw_.GetHashCode();
      if (hasRawSize) hash ^= rawSize_.GetHashCode();
      if (hasZlibData) hash ^= zlibData_.GetHashCode();
      if (hasLzmaData) hash ^= lzmaData_.GetHashCode();
      if (hasOBSOLETEBzip2Data) hash ^= oBSOLETEBzip2Data_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      Blob other = obj as Blob;
      if (other == null) return false;
      if (hasRaw != other.hasRaw || (hasRaw && !raw_.Equals(other.raw_))) return false;
      if (hasRawSize != other.hasRawSize || (hasRawSize && !rawSize_.Equals(other.rawSize_))) return false;
      if (hasZlibData != other.hasZlibData || (hasZlibData && !zlibData_.Equals(other.zlibData_))) return false;
      if (hasLzmaData != other.hasLzmaData || (hasLzmaData && !lzmaData_.Equals(other.lzmaData_))) return false;
      if (hasOBSOLETEBzip2Data != other.hasOBSOLETEBzip2Data || (hasOBSOLETEBzip2Data && !oBSOLETEBzip2Data_.Equals(other.oBSOLETEBzip2Data_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("raw", hasRaw, raw_, writer);
      PrintField("raw_size", hasRawSize, rawSize_, writer);
      PrintField("zlib_data", hasZlibData, zlibData_, writer);
      PrintField("lzma_data", hasLzmaData, lzmaData_, writer);
      PrintField("OBSOLETE_bzip2_data", hasOBSOLETEBzip2Data, oBSOLETEBzip2Data_, writer);
    }
    #endregion
    
    public static Blob ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Blob ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Blob ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Blob ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Blob ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Blob ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Blob ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Blob ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Blob ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Blob ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Blob MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Blob prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilderLite<Blob, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Blob cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Blob result;
      
      private Blob PrepareBuilder() {
        if (resultIsReadOnly) {
          Blob original = result;
          result = new Blob();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Blob MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override Blob DefaultInstanceForType {
        get { return global::OSMPBF.Blob.DefaultInstance; }
      }
      
      public override Blob BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is Blob) {
          return MergeFrom((Blob) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Blob other) {
        if (other == global::OSMPBF.Blob.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRaw) {
          Raw = other.Raw;
        }
        if (other.HasRawSize) {
          RawSize = other.RawSize;
        }
        if (other.HasZlibData) {
          ZlibData = other.ZlibData;
        }
        if (other.HasLzmaData) {
          LzmaData = other.LzmaData;
        }
        if (other.HasOBSOLETEBzip2Data) {
          OBSOLETEBzip2Data = other.OBSOLETEBzip2Data;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_blobFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _blobFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasRaw = input.ReadBytes(ref result.raw_);
              break;
            }
            case 16: {
              result.hasRawSize = input.ReadInt32(ref result.rawSize_);
              break;
            }
            case 26: {
              result.hasZlibData = input.ReadBytes(ref result.zlibData_);
              break;
            }
            case 34: {
              result.hasLzmaData = input.ReadBytes(ref result.lzmaData_);
              break;
            }
            case 42: {
              result.hasOBSOLETEBzip2Data = input.ReadBytes(ref result.oBSOLETEBzip2Data_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasRaw {
        get { return result.hasRaw; }
      }
      public pb::ByteString Raw {
        get { return result.Raw; }
        set { SetRaw(value); }
      }
      public Builder SetRaw(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRaw = true;
        result.raw_ = value;
        return this;
      }
      public Builder ClearRaw() {
        PrepareBuilder();
        result.hasRaw = false;
        result.raw_ = pb::ByteString.Empty;
        return this;
      }
      
      public bool HasRawSize {
        get { return result.hasRawSize; }
      }
      public int RawSize {
        get { return result.RawSize; }
        set { SetRawSize(value); }
      }
      public Builder SetRawSize(int value) {
        PrepareBuilder();
        result.hasRawSize = true;
        result.rawSize_ = value;
        return this;
      }
      public Builder ClearRawSize() {
        PrepareBuilder();
        result.hasRawSize = false;
        result.rawSize_ = 0;
        return this;
      }
      
      public bool HasZlibData {
        get { return result.hasZlibData; }
      }
      public pb::ByteString ZlibData {
        get { return result.ZlibData; }
        set { SetZlibData(value); }
      }
      public Builder SetZlibData(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasZlibData = true;
        result.zlibData_ = value;
        return this;
      }
      public Builder ClearZlibData() {
        PrepareBuilder();
        result.hasZlibData = false;
        result.zlibData_ = pb::ByteString.Empty;
        return this;
      }
      
      public bool HasLzmaData {
        get { return result.hasLzmaData; }
      }
      public pb::ByteString LzmaData {
        get { return result.LzmaData; }
        set { SetLzmaData(value); }
      }
      public Builder SetLzmaData(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLzmaData = true;
        result.lzmaData_ = value;
        return this;
      }
      public Builder ClearLzmaData() {
        PrepareBuilder();
        result.hasLzmaData = false;
        result.lzmaData_ = pb::ByteString.Empty;
        return this;
      }
      
      [global::System.ObsoleteAttribute()]
      public bool HasOBSOLETEBzip2Data {
        get { return result.hasOBSOLETEBzip2Data; }
      }
      [global::System.ObsoleteAttribute()]
      public pb::ByteString OBSOLETEBzip2Data {
        get { return result.OBSOLETEBzip2Data; }
        set { SetOBSOLETEBzip2Data(value); }
      }
      [global::System.ObsoleteAttribute()]
      public Builder SetOBSOLETEBzip2Data(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOBSOLETEBzip2Data = true;
        result.oBSOLETEBzip2Data_ = value;
        return this;
      }
      [global::System.ObsoleteAttribute()]
      public Builder ClearOBSOLETEBzip2Data() {
        PrepareBuilder();
        result.hasOBSOLETEBzip2Data = false;
        result.oBSOLETEBzip2Data_ = pb::ByteString.Empty;
        return this;
      }
    }
    static Blob() {
      object.ReferenceEquals(global::OSMPBF.Fileformat.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class BlobHeader : pb::GeneratedMessageLite<BlobHeader, BlobHeader.Builder> {
    private BlobHeader() { }
    private static readonly BlobHeader defaultInstance = new BlobHeader().MakeReadOnly();
    private static readonly string[] _blobHeaderFieldNames = new string[] { "datasize", "indexdata", "type" };
    private static readonly uint[] _blobHeaderFieldTags = new uint[] { 24, 18, 10 };
    public static BlobHeader DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override BlobHeader DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override BlobHeader ThisMessage {
      get { return this; }
    }
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private string type_ = "";
    public bool HasType {
      get { return hasType; }
    }
    public string Type {
      get { return type_; }
    }
    
    public const int IndexdataFieldNumber = 2;
    private bool hasIndexdata;
    private pb::ByteString indexdata_ = pb::ByteString.Empty;
    public bool HasIndexdata {
      get { return hasIndexdata; }
    }
    public pb::ByteString Indexdata {
      get { return indexdata_; }
    }
    
    public const int DatasizeFieldNumber = 3;
    private bool hasDatasize;
    private int datasize_;
    public bool HasDatasize {
      get { return hasDatasize; }
    }
    public int Datasize {
      get { return datasize_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        if (!hasDatasize) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _blobHeaderFieldNames;
      if (hasType) {
        output.WriteString(1, field_names[2], Type);
      }
      if (hasIndexdata) {
        output.WriteBytes(2, field_names[1], Indexdata);
      }
      if (hasDatasize) {
        output.WriteInt32(3, field_names[0], Datasize);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasType) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Type);
        }
        if (hasIndexdata) {
          size += pb::CodedOutputStream.ComputeBytesSize(2, Indexdata);
        }
        if (hasDatasize) {
          size += pb::CodedOutputStream.ComputeInt32Size(3, Datasize);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasType) hash ^= type_.GetHashCode();
      if (hasIndexdata) hash ^= indexdata_.GetHashCode();
      if (hasDatasize) hash ^= datasize_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      BlobHeader other = obj as BlobHeader;
      if (other == null) return false;
      if (hasType != other.hasType || (hasType && !type_.Equals(other.type_))) return false;
      if (hasIndexdata != other.hasIndexdata || (hasIndexdata && !indexdata_.Equals(other.indexdata_))) return false;
      if (hasDatasize != other.hasDatasize || (hasDatasize && !datasize_.Equals(other.datasize_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("type", hasType, type_, writer);
      PrintField("indexdata", hasIndexdata, indexdata_, writer);
      PrintField("datasize", hasDatasize, datasize_, writer);
    }
    #endregion
    
    public static BlobHeader ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BlobHeader ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BlobHeader ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BlobHeader ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BlobHeader ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BlobHeader ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static BlobHeader ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static BlobHeader ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static BlobHeader ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BlobHeader ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private BlobHeader MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(BlobHeader prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilderLite<BlobHeader, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(BlobHeader cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private BlobHeader result;
      
      private BlobHeader PrepareBuilder() {
        if (resultIsReadOnly) {
          BlobHeader original = result;
          result = new BlobHeader();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override BlobHeader MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override BlobHeader DefaultInstanceForType {
        get { return global::OSMPBF.BlobHeader.DefaultInstance; }
      }
      
      public override BlobHeader BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is BlobHeader) {
          return MergeFrom((BlobHeader) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(BlobHeader other) {
        if (other == global::OSMPBF.BlobHeader.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasIndexdata) {
          Indexdata = other.Indexdata;
        }
        if (other.HasDatasize) {
          Datasize = other.Datasize;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_blobHeaderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _blobHeaderFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasType = input.ReadString(ref result.type_);
              break;
            }
            case 18: {
              result.hasIndexdata = input.ReadBytes(ref result.indexdata_);
              break;
            }
            case 24: {
              result.hasDatasize = input.ReadInt32(ref result.datasize_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasType {
        get { return result.hasType; }
      }
      public string Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = "";
        return this;
      }
      
      public bool HasIndexdata {
        get { return result.hasIndexdata; }
      }
      public pb::ByteString Indexdata {
        get { return result.Indexdata; }
        set { SetIndexdata(value); }
      }
      public Builder SetIndexdata(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasIndexdata = true;
        result.indexdata_ = value;
        return this;
      }
      public Builder ClearIndexdata() {
        PrepareBuilder();
        result.hasIndexdata = false;
        result.indexdata_ = pb::ByteString.Empty;
        return this;
      }
      
      public bool HasDatasize {
        get { return result.hasDatasize; }
      }
      public int Datasize {
        get { return result.Datasize; }
        set { SetDatasize(value); }
      }
      public Builder SetDatasize(int value) {
        PrepareBuilder();
        result.hasDatasize = true;
        result.datasize_ = value;
        return this;
      }
      public Builder ClearDatasize() {
        PrepareBuilder();
        result.hasDatasize = false;
        result.datasize_ = 0;
        return this;
      }
    }
    static BlobHeader() {
      object.ReferenceEquals(global::OSMPBF.Fileformat.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
